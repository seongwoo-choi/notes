---
{"dg-publish":true,"permalink":"/golang/baisic/pointer/","dgPassFrontmatter":true,"created":"2024-01-27T20:09:16.000+09:00","updated":"2024-05-11T11:35:06.124+09:00"}
---

고언어에서 슬라이스, 맵, 채널, 함수, 메서드는 참조 타입이다. 참조 타입은 포인터와 마찬가지로 데이터를 직접 갖지 않고 실제 데이터가 있는 메모리 공간을 가리킨다.

고언어는 C 와 C++ 처럼 포인터 사용을 허용하여 메모리 주소에 직접 접근할 수 있게 하지만, 버그를 유발하기 쉬운 주소값 연산은 허용하지 않는다.

포인터의 역할은 값에 접근하는 수단일 뿐이고, 포인터 변수가 가진 주소 값을 직접 변경할 수는 없다.

```golang
type rect struct{ w, h float64 }

var pRect *rect
var pInt *int
var pFloat *float64
var pComplex *complex128
```

포인터는 다음 두 가지 방식으로 생성한다.

1. & 연산자로 특정 값의 메모리 주소를 포인터 변수에 할당
2. new() 함수로 메모리를 초기화한 후 포인터 변수에 할당

## 주소 연산자(&)로 메모리 주소 할당

변수 앞에 주소 연산자(&)를 붙이면 변수의 메모리 주소를 알아낼 수 있고, 알아낸 메모리 주소를 포인터 변수에 할당해서 사용할 수 있다.

```golang
var p *int

i := 1
p = &i

fmt.Println(i) // 1
fmt.Println(&i) // 0x1043617c
fmt.Println(*p) // 1
fmt.Println(p) // 0x1043617c
```

이 코드에서 볼 수 있듯이 int 타입인 변수 i 와 포인터 변수 p 는 동전의 양면과 같다. i 는 값을 갖고 있고, p 는 i 의 주소를 갖고 있다.

i 에 & 연산자를 붙이면 주소를 알아낼 수 있고, p 에 * 연산자를 붙이면 값을 알아낼 수 있다. 
즉, i 는 * p 와 같고 &i 는 p 와 같다. 그래서 * p 를 int 타입 변수처럼 사용할 수 있다.

```
// remind

변수를 선언할 때 타입 앞 부분에 * 이 있다면, 해당 타입의 메모리 주소를 할당하는 포인터 변수이다.
일반적인 변수에서, 해당 변수의 주솟값을 알고 싶다면 &a 처럼 &변수명을 작성하면 주솟값을 알 수 있다.

포인터 변수의 주솟값 대신 실제 값을 알고 싶다면 *a 처럼 *변수명을 작성하면 실제 변수의 값을 알 수 있다.
```

```golang
type rect sturct{ w, h float64 }

var i int = 1
var p *int = &i
var s *rect = &rect{1, 2}

fmt.Println(p) // 0x82000a260
fmt.Println(s) // &{1 2}
```

구조체 포인터를 출력하면 포인터가 가리키는 값과 포인터인 것을 나타내기 위해 &{1 2} 처럼 주소 연산자(&) 를 함께 출력한다.

일반 변수와 마찬가지로 선언과 동시에 값을 할당하는 경우 타입을 생략할 수 있다.

## 값 전달

고언어에서는 함수나 메서드를 호출할 때 **매개변수 값을 복사해서 함수나 메서드 내부로 전달**한다. 그래서 함수나 메서드 내부에서는 **전달된 매개변수의 원본 값을 변경할 수 없다**.

함수나 메서드 내에서 원본 값을 변경하려면 포인터를 사용해야 한다.

포인터 값의 크기는 64비트 머신에서는 8바이트, 32비트 머신에서는 4바이트이다. 함수나 메서드로 포인터를 전달하면 실제 포인터가 가리키고 있는 값에 상관없이 아주 적은 양의 값만 전달된다.

불 타입이나 숫자 타입 값은 크기가 1바이트에서 8바이트 정도이므로 함수나 메서드 내부로 값을 전달할 때 값을 복사하는 작업이 시스템에 부담을 주지 않는다. 문자열을 전달하는 것도 가볍게 동작한다.

고언어 런타임은 문자열을 전달할 때 실제 그 값이 얼마나 큰지에 상관없이 데이터를 아주 작은 양만 전달하도록 최적화되어 있기 때문이다. 물론 += 같은 작업을 할 때는 문자열 전체를 복사한다.

C 나 C++ 과 달리 고언어의 배열은 값을 복사해서 함수나 메서드 내부로 전달한다. 그래서 큰 배열을 함수나 메서드로 전달하면 시스템에 부담이 많이 된다. 길이가 큰 배열을 함수나 메서드로 전달할 때는 배열 대신 슬라이스를 사용하는 것이 좋다.

함수나 메서드로 슬라이스를 전달하면 참조가 전달되므로 시스템이 덜 부담된다.

```golang
func main() {
	// 함수에 슬라이스를 전달하면 시스템의 부담을 줄일 수 있음
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	 multiply(numbers, 5)
	 fmt.Prinlnl(numbers)
}

func mutiply(numbers []int, factor int) {
	for i := range numbers {
		numbers[i] *= factor
	}
}
```

크기가 큰 구조체를 함수나 메서드에 전달할 때는 값 전체를 복사해서 전달하므로 시스템에 부담을 많이 준다.

이럴 때는 구조체 값을 직접 전달하지 않고 포인터로 전달하면 시스템에 주는 부담을 줄일 수 있다.

```golang
type rect struct {
	x0, y0, x1, y1 int
	color.RGBA
}

func main() {
	rect := rect{2, 4, 10, 20, color.RGBA{0xFF, 0, 0, 0xFF}}
	resize(&rect, 10, 10)
	fmt.Println(rect)
}

func resize(rect *rect, width, height int) {
	rect.x1 += width
	rect.y1 += height
}
```

함수나 메서드의 반환 값이 많을 때는 슬라이스를 변환하거나, 반환 값 여러 개를 구조체로 정의하여 구조체의 포인터를 반환하는 것이 좋다. 함수나 메서드에서 포인터나 참조가 아닌 값을 변경할 때 반환 값은 세 개 이하로 정의하는 것을 권장한다.