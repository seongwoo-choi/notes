---
{"dg-publish":true,"permalink":"/golang/baisic/simplified-channels/","dgPassFrontmatter":true,"created":"2024-04-22T09:52:23.268+09:00","updated":"2024-05-11T11:35:10.074+09:00"}
---

고루틴을 사용하여 동시에 여러 작업을 수행할 수 있다. 이 때 고루틴끼리는 채널을 통해 서로 통신이 가능하다.
#### nil channel
채널을 생성하면 채널은 nil 로 초기화된다.
```golang
func nilChannel() {
	# nil 채널
	var ch chan int

	go fun(){
		# nil 채널에 데이터를 전송, deadlock 발생
		ch<-1
	}

	fmt.Println(<-ch)
}
```

위 코드를 실행하면 고루틴 교착 상태(deadlock) 오류가 발생한다.

위 코드가 실행되지 않는 이유는 'ch' 라는 채널이 선언됐지만 실제로는 초기화되지 않았기 때문이다.

채널은 make 함수를 사용해서 초기화해야 메모리가 할당되고, 데이터의 송수신이 가능해진다. 초기화되지 않은 nil 채널에 데이터를 보내거나 받으려고 하면, 해당 코드는 영원히 대기 상태에 빠지게 된다.

즉, 고루틴에서 nil 채널에 데이터를 보내려고 하면, 채널이 초기화되거나 다른 고루틴이 해당 채넬에서 데이터를 받을 때 까지 무한히 대기하게 된다.

그러나 위 코드의 메인 고루틴도 nil 채널에서 데이터를 받으려고 시도하기 때문에 두 고루틴 모두 영원히 대기 상태에 빠져 프로그램은 교착상태(deadlock)에 빠지게 된다.
#### empty channel
```golang
func emptyChannel() {
    ch := make(chan int)

	ch <- 1

    fmt.Println(<-ch)
}
```

위 코드를 실행하면 deadlock 오류가 발생한다.

위 코드가 실행되지 않는 주된 이유는 메인 고루틴에서 채널 'ch' 에 값을 보내려고 하고, 그 값을 바로 메인 고루틴에서 받으려고 하기 때문이다.

즉, 채널에 데이터를 보내는 작업과 받는 작업이 동일한 고루틴에서 실행되므로, 데이터를 보내는 작업이 완료되기 전에는 받는 작업이 시작될 수 없다. 이로 인해 고루틴이 데드락 상태에 빠지고 프로그램은 멈추게 된다.

채널은 동기화된 커뮤니케이션 메커니즘을 제공하고, 기본적으로 버퍼가 없는 채널은 데이터를 보내는 쪽과 받는 쪽이 모두 준비될 때까지 블로킹 된다.

위 코드에서 'ch <- 1' 구문은 채널에 데이터를 보내는 고루틴이 있을 때 까지 기다린다. 하지만, 데이터를 받을 수 있는 고루틴이 없기 때문에 이 작업은 영원히 기다리게 된다. 

반대로 'fmt.Println(<-ch)' 도 데이터를 보내는 고루틴이 데이터를 보낼 때까지 기다리므로, 영원히 기다리게 된다.
#### unbuffered channel
고루틴 간의 통신을 위해 사용되는 채널 중 가장 기본적인 형태이다. 이 채널은 내부적으로 버퍼를 갖지 않아서 데이터를 보내는 고루틴(send)과 데이터를 받는 고루틴(receive)이 동시에 준비될 때 까지 서로를 블로킹한다.

이 특성 때문에 언버퍼드 채널은 고루틴 간의 직접적인 동기화를 보장한다.

1. 고루틴 동기화: 고루틴 간의 작업을 동기화하고 싶을 때 사용할 수 있다. 한 고루틴이 작업을 완료하고 결과를 다른 고루틴에 전달하며, 이를 통해 고루틴이 동기화된다.
2. 데이터의 순차적 처리: 데이터를 순차적으로 처리해야 할 경우, 언버퍼드 채널을 사용하여 데이터의 처리 순서를 엄격하게 제어할 수 있다.
3. 데드락 감지: 언버퍼드 채널은 송수신 고루틴이 준비되지 않았을 때 블로킹되므로, 프로그램의 데드락 가능성을 조금 더 쉽게 감지할 수 있다.

사용 시 유의점은 아래와 같다.
1. 데드락 위험: 언버퍼드 채널을 사용할 때는 데드락에 주의해야 한다. 송신 고루틴과 수신 고루틴이 동시에 준비되지 않으면 영원히 대기 상태에 빠질 수 있다.
2. 성능 고려: 언버퍼드 채널은 각 메시지마다 고루틴이 블로킹되기 때문에 성능 저하를 유발할 수 있다. 메시지 처리 시간이 길거나 고루틴이 많을 경우 성능 문제가 발생할 수 있다.
3. 테스트와 디버깅: 언버퍼드 채널을 사용하는 코드는 테스트와 디버깅이 어려울 수 있다. 채널을 통한 데이터 흐름과 고루틴의 상태를 정확히 이해하고 있어야 한다.

```golang
func worker(ch chan bool) {
	fmt.Println("working...")
	fmt.Println("Done")
	// 작업 완료 신호를 채널로 전송
	ch <- true
}

func main() {
	ch := make(chan bool)
	go worker(ch)
	// 작업 완료를 기다림
	<-ch
	fmt.Println("worker finished the job")
}
```
위 예제는 'worker' 고루틴이 작업을 마치면 메인 고루틴에 신호를 보내 작업이 완료됐음을 알린다. 언버퍼드 채널 'ch' 는 이 두 고루틴 간의 동기화에 사용된다.
#### buffered channel
내부적으로 데이터를 일정량까지 저장할 수있는 버퍼를 갖는 채널이다. 이 버퍼를 통해 채널이 데이터를 보내는 작업과 받는 작업 사이에 독립성을 제공하여, 채널의 송수신 과정에서 고루틴들이 서로 블로킹되지 않도록 할 수있다.

비동기 작업이나, 데이터 스트리밍 작업이 필요할 경우 버퍼드 채널을 사용하면 유용하게 사용할 수 있다.
1. 비동기 작업: 버퍼드 채널은 producer 와 consumer 의 준비 여부에 관계없이 데이터를 채널에 보낼 수 있도록 한다. 이는 consumer 가 데이터를 처리할 준비가 될 때까지 생산자가 작업을 계속 진행할 수 있게 하여 전체적인 처리 속도를 향상시킬 수 있다.
2. 데이터 스트리밍: 데이터를 스트리밍하는 과정에서 발생할 수 있는 생산과 소비 사이의 처리율 차이를 완화할 수 있다. 예를 들어, 데이터를 생성하는 속도가 소비하는 속도보다 빠를 때 버퍼드 채널을 사용하면, 버퍼 공간이 다 차기 전까지는 블로킹 없이 데이터를 계속 보낼 수 있다.

버퍼드 채널 유의점은 아래와 같다.
1. 데드락: 버퍼가 가득 찬 경우, 추가적인 데이터를 보내려고 하면 고루틴은 버퍼에 공간이 생길 때 까지 블로킹되고, 소비자 가 더 이상 데이터를 받지 않는 상황이면 데드락이 발생할 수 있다.
2. 버퍼 오버플로우: 버퍼 크기를 적절히 설정하지 않으면 버퍼 오버플로우가 발생할 수 있다. 이는 버퍼 크기보다 많은 데이터를 채널에 보내려고 할 때 발생하며, 이 경우 고루틴은 블로킹 상태에 빠지게 된다.
3. 데이터 순서: 버퍼드 채널을 사용하면 데이터의 처리 순서가 보장되지만, 여러 고루틴에서 동시에 데이터를 보내거나 받는 경우, 데이터 처리 순서가 예상과 다를 수 있다. 따라서 동시성을 고려한 설계가 필요하다.
4. 리소스 관리: 버퍼드 채널은 내부적으로 메모리를 사용하므로, 사용하지 않는 채널은 적절히 close 해줘야 한다.

```golang
func main() {
	ch := make(chan int, 2)

	go funt(){
		for i:=0; i<5; i++ {
			fmt.Println("Sending:", i)
			ch <- i // 채널에 데이터 전송
			fmt.Println("Sent:", i)
		}
		close(ch) // 버퍼드 채널은 메모리를 사용하기 때문에 사용이 끝난 채널을 닫는다.
	}

	time.Sleep(2 * time.Second) // 시뮬레이션을 위한 딜레이
	for val := range ch {
		fmt.Println("Received:", val)
	}
	fmt.Println("Channel is closed, loop ends")
}
```

'for  range' 문을 채널과 함께 사용하는 경우 채널('ch')에서 값이 계속 전송될 때까지 대기하고, 값이 들어올 때마다 반복문 내의 코드를 실행한다.

해당 'for range' 구문은 채널이 닫힐 때까지 실행된다.

- 채널을 사용할 때는 송수신 고루틴 간에 적절한 동기화를 고려해야 한다. 채널을 열어두고 닫지 않을 경우 리소스 누수가 발생할 수 있으므로 채널 사용이 끝났을 때는 반드시 닫아야 한다.
- range 를 사용하는 동안 채널이 닫히지 않으면 고루틴이 영원히 대기 상태(데드락)에 빠질 수 있으므로 채널 사용을 잘 관리해야 한다.

#### 작동 원리
- 값 수신: 'for val := range ch' 문은 채널 'ch' 에서 데이터를 수신하고, 변수 'val' 에 그 값을 할당한다.
- 대기 상태: 채널에 데이터가 없을 경우, 채널에서 데이터가 도착할 때 까지 고루틴은 해당 위치에서 블로킹(대기) 상태가 된다.
- 반복 실행: 채널에 데이터가 도착하면 반복문이 실행되어 'val' 변수에 값을 할당하고, 'fmt.Println' 으로 해당 값을 출력한다.
- 채널 종료: 채널이 'close()' 함수를 통해 명시적으로 닫히거나, 데이터를 보내는 측에서 더 이상의 데이터 전송이 없을 경우('close()' 호출), 'range' 문은 더 이상의 데이터를 기다리지 않고 반복문을 종료한다.

![Pasted image 20240422105238.png](/img/user/Golang/static/Pasted%20image%2020240422105238.png)

